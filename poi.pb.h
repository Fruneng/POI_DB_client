// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: poi.proto

#ifndef PROTOBUF_poi_2eproto__INCLUDED
#define PROTOBUF_poi_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace poi {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_poi_2eproto();
void protobuf_AssignDesc_poi_2eproto();
void protobuf_ShutdownFile_poi_2eproto();

class Gps;
class Clouds;
class Mstreet;
class Mark;
class Customer;
class Customer_Rsource;

// ===================================================================

class Gps : public ::google::protobuf::Message {
 public:
  Gps();
  virtual ~Gps();

  Gps(const Gps& from);

  inline Gps& operator=(const Gps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Gps& default_instance();

  void Swap(Gps* other);

  // implements Message ----------------------------------------------

  Gps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Gps& from);
  void MergeFrom(const Gps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double lng = 1;
  inline bool has_lng() const;
  inline void clear_lng();
  static const int kLngFieldNumber = 1;
  inline double lng() const;
  inline void set_lng(double value);

  // required double lat = 2;
  inline bool has_lat() const;
  inline void clear_lat();
  static const int kLatFieldNumber = 2;
  inline double lat() const;
  inline void set_lat(double value);

  // optional double height = 3;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 3;
  inline double height() const;
  inline void set_height(double value);

  // optional int32 speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // optional int32 direction = 5;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional int32 color = 6;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 6;
  inline ::google::protobuf::int32 color() const;
  inline void set_color(::google::protobuf::int32 value);

  // optional int32 time = 7;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 7;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:poi.Gps)
 private:
  inline void set_has_lng();
  inline void clear_has_lng();
  inline void set_has_lat();
  inline void clear_has_lat();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double lng_;
  double lat_;
  double height_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 color_;
  ::google::protobuf::int32 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Gps* default_instance_;
};
// -------------------------------------------------------------------

class Clouds : public ::google::protobuf::Message {
 public:
  Clouds();
  virtual ~Clouds();

  Clouds(const Clouds& from);

  inline Clouds& operator=(const Clouds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Clouds& default_instance();

  void Swap(Clouds* other);

  // implements Message ----------------------------------------------

  Clouds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Clouds& from);
  void MergeFrom(const Clouds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .poi.Gps gps = 1;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 1;
  inline const ::poi::Gps& gps() const;
  inline ::poi::Gps* mutable_gps();
  inline ::poi::Gps* release_gps();
  inline void set_allocated_gps(::poi::Gps* gps);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // @@protoc_insertion_point(class_scope:poi.Clouds)
 private:
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::poi::Gps* gps_;
  ::std::string* username_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Clouds* default_instance_;
};
// -------------------------------------------------------------------

class Mstreet : public ::google::protobuf::Message {
 public:
  Mstreet();
  virtual ~Mstreet();

  Mstreet(const Mstreet& from);

  inline Mstreet& operator=(const Mstreet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mstreet& default_instance();

  void Swap(Mstreet* other);

  // implements Message ----------------------------------------------

  Mstreet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mstreet& from);
  void MergeFrom(const Mstreet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .poi.Gps gps = 1;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 1;
  inline const ::poi::Gps& gps() const;
  inline ::poi::Gps* mutable_gps();
  inline ::poi::Gps* release_gps();
  inline void set_allocated_gps(::poi::Gps* gps);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int32 level_height = 4;
  inline bool has_level_height() const;
  inline void clear_level_height();
  static const int kLevelHeightFieldNumber = 4;
  inline ::google::protobuf::int32 level_height() const;
  inline void set_level_height(::google::protobuf::int32 value);

  // required string city = 5;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 5;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // required int32 onewany_dir = 6;
  inline bool has_onewany_dir() const;
  inline void clear_onewany_dir();
  static const int kOnewanyDirFieldNumber = 6;
  inline ::google::protobuf::int32 onewany_dir() const;
  inline void set_onewany_dir(::google::protobuf::int32 value);

  // required int32 zoomlayer = 7;
  inline bool has_zoomlayer() const;
  inline void clear_zoomlayer();
  static const int kZoomlayerFieldNumber = 7;
  inline ::google::protobuf::int32 zoomlayer() const;
  inline void set_zoomlayer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:poi.Mstreet)
 private:
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_level_height();
  inline void clear_has_level_height();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_onewany_dir();
  inline void clear_has_onewany_dir();
  inline void set_has_zoomlayer();
  inline void clear_has_zoomlayer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::poi::Gps* gps_;
  ::std::string* username_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 level_height_;
  ::std::string* city_;
  ::google::protobuf::int32 onewany_dir_;
  ::google::protobuf::int32 zoomlayer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Mstreet* default_instance_;
};
// -------------------------------------------------------------------

class Mark : public ::google::protobuf::Message {
 public:
  Mark();
  virtual ~Mark();

  Mark(const Mark& from);

  inline Mark& operator=(const Mark& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mark& default_instance();

  void Swap(Mark* other);

  // implements Message ----------------------------------------------

  Mark* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mark& from);
  void MergeFrom(const Mark& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .poi.Gps gps = 1;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 1;
  inline const ::poi::Gps& gps() const;
  inline ::poi::Gps* mutable_gps();
  inline ::poi::Gps* release_gps();
  inline void set_allocated_gps(::poi::Gps* gps);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string memo = 4;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 4;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  inline void set_allocated_memo(::std::string* memo);

  // @@protoc_insertion_point(class_scope:poi.Mark)
 private:
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_memo();
  inline void clear_has_memo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::poi::Gps* gps_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::std::string* memo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Mark* default_instance_;
};
// -------------------------------------------------------------------

class Customer_Rsource : public ::google::protobuf::Message {
 public:
  Customer_Rsource();
  virtual ~Customer_Rsource();

  Customer_Rsource(const Customer_Rsource& from);

  inline Customer_Rsource& operator=(const Customer_Rsource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Customer_Rsource& default_instance();

  void Swap(Customer_Rsource* other);

  // implements Message ----------------------------------------------

  Customer_Rsource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Customer_Rsource& from);
  void MergeFrom(const Customer_Rsource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:poi.Customer.Rsource)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Customer_Rsource* default_instance_;
};
// -------------------------------------------------------------------

class Customer : public ::google::protobuf::Message {
 public:
  Customer();
  virtual ~Customer();

  Customer(const Customer& from);

  inline Customer& operator=(const Customer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Customer& default_instance();

  void Swap(Customer* other);

  // implements Message ----------------------------------------------

  Customer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Customer& from);
  void MergeFrom(const Customer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Customer_Rsource Rsource;

  // accessors -------------------------------------------------------

  // required .poi.Gps gps = 1;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 1;
  inline const ::poi::Gps& gps() const;
  inline ::poi::Gps* mutable_gps();
  inline ::poi::Gps* release_gps();
  inline void set_allocated_gps(::poi::Gps* gps);

  // required string picname = 2;
  inline bool has_picname() const;
  inline void clear_picname();
  static const int kPicnameFieldNumber = 2;
  inline const ::std::string& picname() const;
  inline void set_picname(const ::std::string& value);
  inline void set_picname(const char* value);
  inline void set_picname(const char* value, size_t size);
  inline ::std::string* mutable_picname();
  inline ::std::string* release_picname();
  inline void set_allocated_picname(::std::string* picname);

  // required string username = 3;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 3;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string memo = 4;
  inline bool has_memo() const;
  inline void clear_memo();
  static const int kMemoFieldNumber = 4;
  inline const ::std::string& memo() const;
  inline void set_memo(const ::std::string& value);
  inline void set_memo(const char* value);
  inline void set_memo(const char* value, size_t size);
  inline ::std::string* mutable_memo();
  inline ::std::string* release_memo();
  inline void set_allocated_memo(::std::string* memo);

  // optional .poi.Customer.Rsource res = 5;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 5;
  inline const ::poi::Customer_Rsource& res() const;
  inline ::poi::Customer_Rsource* mutable_res();
  inline ::poi::Customer_Rsource* release_res();
  inline void set_allocated_res(::poi::Customer_Rsource* res);

  // @@protoc_insertion_point(class_scope:poi.Customer)
 private:
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_picname();
  inline void clear_has_picname();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_memo();
  inline void clear_has_memo();
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::poi::Gps* gps_;
  ::std::string* picname_;
  ::std::string* username_;
  ::std::string* memo_;
  ::poi::Customer_Rsource* res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_poi_2eproto();
  friend void protobuf_AssignDesc_poi_2eproto();
  friend void protobuf_ShutdownFile_poi_2eproto();

  void InitAsDefaultInstance();
  static Customer* default_instance_;
};
// ===================================================================


// ===================================================================

// Gps

// required double lng = 1;
inline bool Gps::has_lng() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Gps::set_has_lng() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Gps::clear_has_lng() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Gps::clear_lng() {
  lng_ = 0;
  clear_has_lng();
}
inline double Gps::lng() const {
  return lng_;
}
inline void Gps::set_lng(double value) {
  set_has_lng();
  lng_ = value;
}

// required double lat = 2;
inline bool Gps::has_lat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Gps::set_has_lat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Gps::clear_has_lat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Gps::clear_lat() {
  lat_ = 0;
  clear_has_lat();
}
inline double Gps::lat() const {
  return lat_;
}
inline void Gps::set_lat(double value) {
  set_has_lat();
  lat_ = value;
}

// optional double height = 3;
inline bool Gps::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Gps::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Gps::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Gps::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Gps::height() const {
  return height_;
}
inline void Gps::set_height(double value) {
  set_has_height();
  height_ = value;
}

// optional int32 speed = 4;
inline bool Gps::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Gps::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Gps::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Gps::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 Gps::speed() const {
  return speed_;
}
inline void Gps::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
}

// optional int32 direction = 5;
inline bool Gps::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Gps::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Gps::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Gps::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 Gps::direction() const {
  return direction_;
}
inline void Gps::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional int32 color = 6;
inline bool Gps::has_color() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Gps::set_has_color() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Gps::clear_has_color() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Gps::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::google::protobuf::int32 Gps::color() const {
  return color_;
}
inline void Gps::set_color(::google::protobuf::int32 value) {
  set_has_color();
  color_ = value;
}

// optional int32 time = 7;
inline bool Gps::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Gps::set_has_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Gps::clear_has_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Gps::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 Gps::time() const {
  return time_;
}
inline void Gps::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Clouds

// required .poi.Gps gps = 1;
inline bool Clouds::has_gps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Clouds::set_has_gps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Clouds::clear_has_gps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Clouds::clear_gps() {
  if (gps_ != NULL) gps_->::poi::Gps::Clear();
  clear_has_gps();
}
inline const ::poi::Gps& Clouds::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::poi::Gps* Clouds::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::poi::Gps;
  return gps_;
}
inline ::poi::Gps* Clouds::release_gps() {
  clear_has_gps();
  ::poi::Gps* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void Clouds::set_allocated_gps(::poi::Gps* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// required string username = 2;
inline bool Clouds::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Clouds::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Clouds::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Clouds::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Clouds::username() const {
  return *username_;
}
inline void Clouds::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Clouds::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Clouds::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Clouds::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Clouds::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Clouds::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Mstreet

// required .poi.Gps gps = 1;
inline bool Mstreet::has_gps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mstreet::set_has_gps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mstreet::clear_has_gps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mstreet::clear_gps() {
  if (gps_ != NULL) gps_->::poi::Gps::Clear();
  clear_has_gps();
}
inline const ::poi::Gps& Mstreet::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::poi::Gps* Mstreet::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::poi::Gps;
  return gps_;
}
inline ::poi::Gps* Mstreet::release_gps() {
  clear_has_gps();
  ::poi::Gps* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void Mstreet::set_allocated_gps(::poi::Gps* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// required int32 id = 2;
inline bool Mstreet::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mstreet::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mstreet::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mstreet::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Mstreet::id() const {
  return id_;
}
inline void Mstreet::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string username = 3;
inline bool Mstreet::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mstreet::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mstreet::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mstreet::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Mstreet::username() const {
  return *username_;
}
inline void Mstreet::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Mstreet::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Mstreet::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mstreet::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Mstreet::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mstreet::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 level_height = 4;
inline bool Mstreet::has_level_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mstreet::set_has_level_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mstreet::clear_has_level_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mstreet::clear_level_height() {
  level_height_ = 0;
  clear_has_level_height();
}
inline ::google::protobuf::int32 Mstreet::level_height() const {
  return level_height_;
}
inline void Mstreet::set_level_height(::google::protobuf::int32 value) {
  set_has_level_height();
  level_height_ = value;
}

// required string city = 5;
inline bool Mstreet::has_city() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mstreet::set_has_city() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mstreet::clear_has_city() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mstreet::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& Mstreet::city() const {
  return *city_;
}
inline void Mstreet::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Mstreet::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void Mstreet::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mstreet::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* Mstreet::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mstreet::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 onewany_dir = 6;
inline bool Mstreet::has_onewany_dir() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Mstreet::set_has_onewany_dir() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Mstreet::clear_has_onewany_dir() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Mstreet::clear_onewany_dir() {
  onewany_dir_ = 0;
  clear_has_onewany_dir();
}
inline ::google::protobuf::int32 Mstreet::onewany_dir() const {
  return onewany_dir_;
}
inline void Mstreet::set_onewany_dir(::google::protobuf::int32 value) {
  set_has_onewany_dir();
  onewany_dir_ = value;
}

// required int32 zoomlayer = 7;
inline bool Mstreet::has_zoomlayer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Mstreet::set_has_zoomlayer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Mstreet::clear_has_zoomlayer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Mstreet::clear_zoomlayer() {
  zoomlayer_ = 0;
  clear_has_zoomlayer();
}
inline ::google::protobuf::int32 Mstreet::zoomlayer() const {
  return zoomlayer_;
}
inline void Mstreet::set_zoomlayer(::google::protobuf::int32 value) {
  set_has_zoomlayer();
  zoomlayer_ = value;
}

// -------------------------------------------------------------------

// Mark

// required .poi.Gps gps = 1;
inline bool Mark::has_gps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mark::set_has_gps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mark::clear_has_gps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mark::clear_gps() {
  if (gps_ != NULL) gps_->::poi::Gps::Clear();
  clear_has_gps();
}
inline const ::poi::Gps& Mark::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::poi::Gps* Mark::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::poi::Gps;
  return gps_;
}
inline ::poi::Gps* Mark::release_gps() {
  clear_has_gps();
  ::poi::Gps* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void Mark::set_allocated_gps(::poi::Gps* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// required int32 id = 2;
inline bool Mark::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mark::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mark::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mark::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Mark::id() const {
  return id_;
}
inline void Mark::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 type = 3;
inline bool Mark::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mark::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mark::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mark::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Mark::type() const {
  return type_;
}
inline void Mark::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string memo = 4;
inline bool Mark::has_memo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mark::set_has_memo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mark::clear_has_memo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mark::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& Mark::memo() const {
  return *memo_;
}
inline void Mark::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Mark::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Mark::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Mark::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* Mark::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Mark::set_allocated_memo(::std::string* memo) {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    delete memo_;
  }
  if (memo) {
    set_has_memo();
    memo_ = memo;
  } else {
    clear_has_memo();
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Customer_Rsource

// required int32 type = 1;
inline bool Customer_Rsource::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Customer_Rsource::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Customer_Rsource::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Customer_Rsource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Customer_Rsource::type() const {
  return type_;
}
inline void Customer_Rsource::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string url = 2;
inline bool Customer_Rsource::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Customer_Rsource::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Customer_Rsource::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Customer_Rsource::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Customer_Rsource::url() const {
  return *url_;
}
inline void Customer_Rsource::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Customer_Rsource::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Customer_Rsource::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Customer_Rsource::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Customer_Rsource::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Customer_Rsource::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Customer

// required .poi.Gps gps = 1;
inline bool Customer::has_gps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Customer::set_has_gps() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Customer::clear_has_gps() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Customer::clear_gps() {
  if (gps_ != NULL) gps_->::poi::Gps::Clear();
  clear_has_gps();
}
inline const ::poi::Gps& Customer::gps() const {
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::poi::Gps* Customer::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::poi::Gps;
  return gps_;
}
inline ::poi::Gps* Customer::release_gps() {
  clear_has_gps();
  ::poi::Gps* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void Customer::set_allocated_gps(::poi::Gps* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
}

// required string picname = 2;
inline bool Customer::has_picname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Customer::set_has_picname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Customer::clear_has_picname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Customer::clear_picname() {
  if (picname_ != &::google::protobuf::internal::kEmptyString) {
    picname_->clear();
  }
  clear_has_picname();
}
inline const ::std::string& Customer::picname() const {
  return *picname_;
}
inline void Customer::set_picname(const ::std::string& value) {
  set_has_picname();
  if (picname_ == &::google::protobuf::internal::kEmptyString) {
    picname_ = new ::std::string;
  }
  picname_->assign(value);
}
inline void Customer::set_picname(const char* value) {
  set_has_picname();
  if (picname_ == &::google::protobuf::internal::kEmptyString) {
    picname_ = new ::std::string;
  }
  picname_->assign(value);
}
inline void Customer::set_picname(const char* value, size_t size) {
  set_has_picname();
  if (picname_ == &::google::protobuf::internal::kEmptyString) {
    picname_ = new ::std::string;
  }
  picname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Customer::mutable_picname() {
  set_has_picname();
  if (picname_ == &::google::protobuf::internal::kEmptyString) {
    picname_ = new ::std::string;
  }
  return picname_;
}
inline ::std::string* Customer::release_picname() {
  clear_has_picname();
  if (picname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = picname_;
    picname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Customer::set_allocated_picname(::std::string* picname) {
  if (picname_ != &::google::protobuf::internal::kEmptyString) {
    delete picname_;
  }
  if (picname) {
    set_has_picname();
    picname_ = picname;
  } else {
    clear_has_picname();
    picname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 3;
inline bool Customer::has_username() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Customer::set_has_username() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Customer::clear_has_username() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Customer::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& Customer::username() const {
  return *username_;
}
inline void Customer::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Customer::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void Customer::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Customer::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* Customer::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Customer::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string memo = 4;
inline bool Customer::has_memo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Customer::set_has_memo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Customer::clear_has_memo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Customer::clear_memo() {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    memo_->clear();
  }
  clear_has_memo();
}
inline const ::std::string& Customer::memo() const {
  return *memo_;
}
inline void Customer::set_memo(const ::std::string& value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Customer::set_memo(const char* value) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(value);
}
inline void Customer::set_memo(const char* value, size_t size) {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  memo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Customer::mutable_memo() {
  set_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    memo_ = new ::std::string;
  }
  return memo_;
}
inline ::std::string* Customer::release_memo() {
  clear_has_memo();
  if (memo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = memo_;
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Customer::set_allocated_memo(::std::string* memo) {
  if (memo_ != &::google::protobuf::internal::kEmptyString) {
    delete memo_;
  }
  if (memo) {
    set_has_memo();
    memo_ = memo;
  } else {
    clear_has_memo();
    memo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .poi.Customer.Rsource res = 5;
inline bool Customer::has_res() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Customer::set_has_res() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Customer::clear_has_res() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Customer::clear_res() {
  if (res_ != NULL) res_->::poi::Customer_Rsource::Clear();
  clear_has_res();
}
inline const ::poi::Customer_Rsource& Customer::res() const {
  return res_ != NULL ? *res_ : *default_instance_->res_;
}
inline ::poi::Customer_Rsource* Customer::mutable_res() {
  set_has_res();
  if (res_ == NULL) res_ = new ::poi::Customer_Rsource;
  return res_;
}
inline ::poi::Customer_Rsource* Customer::release_res() {
  clear_has_res();
  ::poi::Customer_Rsource* temp = res_;
  res_ = NULL;
  return temp;
}
inline void Customer::set_allocated_res(::poi::Customer_Rsource* res) {
  delete res_;
  res_ = res;
  if (res) {
    set_has_res();
  } else {
    clear_has_res();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace poi

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_poi_2eproto__INCLUDED
